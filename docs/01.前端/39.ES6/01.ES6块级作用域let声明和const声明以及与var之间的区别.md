---
title: ES6块级作用域let声明和const声明以及与var之间的区别
date: 2023-02-09 14:53:00
permalink: /pages/921559/
categories:
  - 前端
  - ES6
tags:
  - ES6
author: 
  name: zhangzuying
  link: https://zhangzuying.github.io/
---
#一、ES6块级作用域
## let 声明

> 块级声明用于声明在指定作用域之外无法访问的变量，存在于：

①函数内部
②块内（字符{和}之间的区域）
##### 禁止重声明
（1）如果在作用域由已经存在某个标识，再用let声明时会报错
```
var name = 'zhang'
let name = 'wang' // 报错
```
（2）如果在当前作用域内嵌另一个作用域，使可在内嵌的作用域中用let声明同名变量，代码如下：
```
var name = 'zhang'
if(status){
	let name = 'wang' // 不会报错  
}
```
## const 声明
> 声明的是常量，一旦被设定后不可更改，所以，每个通过const声明的常量必须进行初始化。

`正确：const name = 'zhang';`
`错误：const name;`
#### const 与 let
> 相同之处：都是块级标识符，只在当前代码块内有效，不会提升至作用域顶部。
不同之处：无论在严格模式下还是非严格模式下，都不可以为const 定义的常量再赋值，否则会报错。

#### 用const 声明对象
> const 声明不允许修改绑定，但允许修改值，也就是说，用const声明对象后，可以修改该对象的属性值，代码如下：

```
const person = { name : 'zhang' };
// 可以修改对象属性的值 person.name = 'wang'
// 报错 person = { name:'wang' }
```
#### 临时死区
> let和const与var不同，声明的变量不会被提升到作用域的顶部，不可在声明之前访问这些变量。

```
if(status){
 console.log(typeof value);
 let value = "blue";
}
// 此时的console.log()会报错，此时的value还位于“临时死区”或TDZ中。
```

#### 全局块作用域绑定
> let和const与var的另一个区别是它们在全局作用域中的行为，当var被用于全局作用域时，会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性。var 声明的变量会无意中覆盖一个已经存在的全局属性。代码如下：
```
var RegExp = 'Hello'
console.log(window.RegExp) // Hello (覆盖)
```

#### 块级绑定最佳实践
> 默认使用const，只在确定需要改变变量的值时使用let，这样就可以在某种程度上实现代码的不可变。防止某些错误的产生。
